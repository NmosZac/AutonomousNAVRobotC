#pragma config(Sensor, S1, Eyes, sensorSONAR)
#pragma config(Sensor, S2, Compass, sensorSONAR)
#pragma config(Sensor, S3, TDer, sensorTouch)
#pragma config(Sensor, S4, TIzq, sensorTouch)
#pragma config(Motor,  motorA, Mder, tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB, Mizq, tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC, Direccion, tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Programa para que el robot NXT decifre un camino dentro de un laberinto, donde evaluara
la distancia que existe entre el robot y los obtaculos y poder determinar una direccion
mas adecuada*/

/*Programador: Nicolás Morales Samaniego*/
/*Año: 2011 */
/*************************Declaracion de variables globales*****************/
typedef struct
{
  int ObsFre;
  int ObsDer;
  int ObsIzq;
  int PasoAnt;
  int Time;
  int Visita;
}Casilla;

int x=0;// Variable que identifica cada argumento del arreglo USpos

int ValorSonar;//Variable que guarda el valor del sensor sonar.
int ValorCompass;//Variable que guarda el valor del sensor del compas magnetico
int ValorLuz;
int OF;
int OD;
int OI;
int Dir_Salida=0;
int Pos_Actual=0;
const int gradosDesicion=90;//Grados de giro del motor Direccion.
const int grados=70;//Grados de giro para dar vuelta al robot.
const int distancia_en_cm=30;//Limite de acercamiento a obstaculos.
int speed=50;
int velDir=5; // Velocidad con la que se mueve el motor Direccion.


int tiempo_avance=0;//Variable global que almacena el tiempo de avance.
int omision=0;//Variable de control de obstaculo bajo

Casilla USpos[20];//Arreglo de tipo Casilla donde se creara una memoria para identificar la
                  //serie de pasos que ha realizado el robot.
/*********************************************************************/


/**************************Declaracion de funciones********************/

void Avanzar();
void Velocidad(int sentido, int VelDer, int VelIzq);
void ControlDirI(int b);
void ControlDirD(int b);
void Parar();
void Reversa();
void ReversaCorreccion();
int GiroDerecha(int sent);
int GiroIzquierda(int sent);
void Posicion(int datoX,int left,int front,int right,int PS,int T, int Vis);

int HeadDer();
int HeadIzq();
void HeadFront(int giro);
void ObstaculosCasilla(int PS);
int CasoCompass();
int DecidirAccion();
/*********************************************************************/


/**************************Funciones*******************************/
/*funciones que despliegan informacion en la pantalla mientras corre el programa*/
task MonitorSonar(){
  while(true){
    ValorSonar=SensorValue[Eyes];
     }
  }

task MonitorCompass(){
  while(true){
    ValorCompass=SensorValue[Compass]*2;/*El sensor Compass Magnetico se usa como
                                      sensor Sonar y nos muestra valores en grados/2*/
    }
  }
task MonitorLuz(){
  btConnect(1,"Basura");
  while(true){
  if(bQueuedMsgAvailable()){
    eraseDisplay();
    nxtDisplayCenteredTextLine(3,"%d",messageParm[0]);
    ValorLuz=messageParm[0];
    ClearMessage();
  }
  wait1Msec(100);
 }
}

task Pantalla(){
  while(true){
    nxtDisplayTextLine(1,"Posicion X:%d",x);//despliegue en pantalla
    nxtDisplayTextLine(2,"OF:%d OD:%d ",USpos[x].ObsFre,USpos[x].ObsDer);
    nxtDisplayTextLine(3,"OI:%d Vpos:%d",USpos[x].ObsIzq,USpos[x].Visita);
    nxtDisplayCenteredTextLine(4, "VS:%d, VC:%d", ValorSonar, ValorCompass);
    nxtDisplayCenteredTextLine(5, "VLUZ:%d", ValorLuz);
    nxtDisplayTextLine(6,"Dir Salida:%d",Dir_Salida);
    nxtDisplayTextLine(7,"Pos_Actual:%d",Pos_Actual);
    wait1Msec(50);
    }
  }

/****************************************************************/



/*****************Funciones de movimientos basicos del robot***********/

void Avanzar()
{
 int Referencia;

 Referencia=ValorCompass;
 nxtDisplayTextLine(1,"Referencia:%d",Referencia);
 ClearTimer(T1);//Inicializa el timer T1
 Velocidad(1,speed,speed);

 ControlDirI(13);/*En este robot se requiere un ajuste previo al avanzar
                    permite que siga una linea recta. 13 grados necesarios para
                    corregir Error de desviacion*/

 while(SensorValue[Eyes] > distancia_en_cm && SensorValue[TDer]==0 && SensorValue[TIzq]==0 ){
   if(ValorLuz>40){
     Parar();
     StopTask(Pantalla);
     eraseDisplay();
     while(true){
      nxtDisplayCenteredBigTextLine(3,"Fin");
      }
     }
   }//fin del while

 Parar();
 tiempo_avance=time10[T1];//Tiempo al final del avance.

 /*Permite deplazarse hacia atras en caso de un obstaculo muy cercano*/
    if(SensorValue[TDer]==1 || SensorValue[TIzq]==1){
      omision=1;//omite evaluar al frente y definir que hay obstaculo
     Velocidad(-1,speed,speed);
       wait10Msec(0050);
       Parar();
       tiempo_avance=tiempo_avance-50;
      }

  wait1Msec(0500);


}

void Velocidad(int sentido, int VelDer, int VelIzq){
  motor[Mder]=sentido*VelDer;
  motor[Mizq]=sentido*VelIzq;
}

void ControlDirI(int b){ //funcion que corrige la direccion del robot

  bMotorReflected[Direccion]=0; //giro a la izquierda
  nMotorEncoder[Direccion]=0;//Restablece encoder inicial=0
  nMotorEncoderTarget[Direccion]=b;//Grados de giro
  motor[Direccion]=velDir;//velocidad de giro
  while(nMotorRunState[Direccion] != runStateIdle){
    }
  motor[Direccion]=0;
}

void ControlDirD(int b){ //funcion que corrige la direccion del robot

  bMotorReflected[Direccion]=1; //giro a la derecha
  nMotorEncoder[Direccion]=0;
  nMotorEncoderTarget[Direccion]=b;
  motor[Direccion]=velDir;
  while(nMotorRunState[Direccion] != runStateIdle){
    }
  motor[Direccion]=0;
}

void Parar(){

  motor[Mder]=0;
  motor[Mizq]=0;
}

void Reversa(){// se mantiene en retroceso hasta llegar a la posicion anterior

  ClearTimer(T2);

    Velocidad(-1,speed,speed);
    ControlDirI(13);/*En este robot se requiere un ajuste previo al avanzar
                    permite que siga una linea recta. 13 grados necesarios para
                    corregir Error de desviacion*/

 while(time10[T2]<= USpos[x].Time){   //Retrocede en un tiempo igual al que llego a su posicion actual
    }//fin del while
     Parar();
     wait1Msec(0500);
}

void ReversaCorreccion(){
  wait1Msec(500);
  Velocidad(-1,20,20);
  wait1Msec(1000);
  Parar();
}

int GiroDerecha(int sent){

 int tiempo_giro;
 int time;
 if(sent==1)
 time=2500;
 else if(sent==-1)
 time=2500;

 nMotorEncoder[Direccion]=0;
 bMotorReflected[Direccion]=1;//Gira a la derecha
 nMotorEncoderTarget[Direccion]=grados;
 motor[Direccion]=velDir;
 wait1Msec(1000);
 ClearTimer(T2);

 Velocidad(sent,12,25);

 while(time1[T2]<time&&SensorValue[TDer]==0&&SensorValue[TIzq]==0){//Gira a la derecha en 2.5s
    }//fin del while
 /*Resuleve problema de un obstaculo cuando el robot da vuelta*/
 tiempo_giro=time1[T2];
 Parar();
    if(SensorValue[TDer]==1 || SensorValue[TIzq]==1){
       sent=-1;
       ClearTimer(T2);
       Velocidad(sent,12,25);
       while(time1[T2]<=tiempo_giro){
       }
       Parar();
       bMotorReflected[Direccion]=0;
       nMotorEncoderTarget[Direccion]=grados;
       motor[Direccion]=velDir;
       wait1Msec(1000);

      return 1;//Existio problemas para girar
   }
/*************************/
 bMotorReflected[Direccion]=0;
 nMotorEncoderTarget[Direccion]=grados;
 motor[Direccion]=velDir;
 wait1Msec(1500);

 return 0;//Giro exitoso
}


int GiroIzquierda(int sent){

 int tiempo_giro;
 int time;

 if(sent==1)
   time=2500;
 else if(sent==-1)
   time=2500;
 nMotorEncoder[Direccion]=0;
 bMotorReflected[Direccion]=0;//Gira a la izquierda
 nMotorEncoderTarget[Direccion]=grados;
 motor[Direccion]=velDir;
 wait1Msec(1000);
 ClearTimer(T2);

 Velocidad(sent,25,12);

 while(time1[T2]<time&&SensorValue[TDer]==0&&SensorValue[TIzq]==0){   //Gira a la izquierda en girar 3.2s
    }//fin del while

/*Resuleve problema de un obstaculo cuando el robot da vuelta*/
 tiempo_giro=time1[T2];
 Parar();
     if(SensorValue[TDer]==1 || SensorValue[TIzq]==1){
        sent=-1;
        ClearTimer(T2);
        Velocidad(sent,25,12);
        while(time1[T2]<=tiempo_giro){
        }
        Parar();

  bMotorReflected[Direccion]=1;
  nMotorEncoderTarget[Direccion]=grados;
  motor[Direccion]=velDir;
  wait1Msec(1000);

  return 1;//Existio problemas para girar
  }
/*************************/

  bMotorReflected[Direccion]=1;
  nMotorEncoderTarget[Direccion]=grados;
  motor[Direccion]=velDir;
  wait1Msec(1500);
  return 0;//Giro exitoso
}


/**********************************************************************/


/*********************Funciones para identificacion de obstaculos*******/

int HeadDer()
{
 bMotorReflected[Direccion]=1;
 nMotorEncoder[Direccion]=0;
 nMotorEncoderTarget[Direccion] = gradosDesicion;
 motor[Direccion] = velDir;
 wait1Msec(1800);
 motor[Direccion] = 0;  // Parar el motor de la cabeza

 return 0;
}


int HeadIzq()
{
  nMotorEncoder[Direccion]=0;
  nMotorEncoderTarget[Direccion] = gradosDesicion;        // Set the  target for Motor Encoder of Motor A to 90.
  motor[Direccion] = velDir; // Motor B is run at a power level of 10.
  wait1Msec(1800);
  motor[Direccion]=0;

  return 1;
}

void HeadFront(int giro) //parametro recibido para definir sentido de giro
{
  nMotorEncoder[Direccion]=0;
  if(giro==1)//vuelta derecha al frente
  {
    bMotorReflected[Direccion]=giro;
    nMotorEncoderTarget[Direccion]=gradosDesicion;
    motor[Direccion] = velDir;
    wait1Msec(1500);
  }
  else if(giro==0)//vuelta de izquerda al frente
  {
    bMotorReflected[Direccion]=giro;
    nMotorEncoderTarget[Direccion]=gradosDesicion;
    motor[Direccion] = velDir;
    wait1Msec(1500);
  }
}//fin de la funcion

/******Funciones de memoria del Laberinto**************************************/
int CasoCompass(){

 if(USpos[x].ObsDer==1&&USpos[x].ObsIzq==1&&USpos[x].ObsFre==0)//Caso especial para decidir entre 2 caminos
                                                               //Izquierda o derecha
 {
   wait1Msec(0500);
   Pos_Actual=SensorValue[Compass]*2;

  if(Dir_Salida>=0 && Dir_Salida<=90){ //Caso de coordenada de salida entre 0 y 90
                             //Este dato Dir_Salida fue tomada por el usuario al inicio del programa
         if (Pos_Actual>=0 && Pos_Actual<=90){

            if(Pos_Actual<=Dir_Salida)
              return 2;//Gira a la derecha
            else
              return 3;

          }

         else if(Pos_Actual>=91&&Pos_Actual<=180)

              return 3;//Gira a la izquierda

         else if (Pos_Actual>=271&&Pos_Actual<=359)

              return 2;//Gira a la derecha

         else if (Pos_Actual>=181&&Pos_Actual<=270){
              Pos_Actual=Pos_Actual-Dir_Salida;

              if(Pos_Actual<180)
              return 3;//Gira a la izquierda

              else
              return 2;//Gira a la derecha

            }//fin del else if
      }//Fin del if caso 1

    else if(Dir_Salida>=91 && Dir_Salida<=180){//Caso de coordenada de salida entre 91 y 180

         if (Pos_Actual>=0 && Pos_Actual<=90)
              return 2;//Gira a la derecha

         else if(Pos_Actual>=91&&Pos_Actual<=180){

            if(Pos_Actual<Dir_Salida)
              return 2;//Gira a la derecha
            else
              return 3;//Gira a la izquierda
             }
         else if (Pos_Actual>=181&&Pos_Actual<=270)

              return 3;//Gira a la izquierda

         else if (Pos_Actual>=271&&Pos_Actual<=359){
              Pos_Actual=Pos_Actual-Dir_Salida;

              if(Pos_Actual<180)
              return 3;//Gira a la izquierda

              else
              return 2;//Gira a la derecha
            }
       }//Fin del else if caso 2

     else if(Dir_Salida>=181 && Dir_Salida<=270){//Caso de coordenada de salida entre 181 y 270

         if (Pos_Actual>=0 && Pos_Actual<=90){
              Pos_Actual=Dir_Salida-Pos_Actual;

              if(Pos_Actual>180)
              return 3;//Gira a la izquierda

              else
              return 2;//Gira a la derecha

            }
         else if(Pos_Actual>=91&&Pos_Actual<=180)

              return 2;//Gira a la derecha

         else if (Pos_Actual>=181&&Pos_Actual<=270){

              if(Pos_Actual<Dir_Salida)
              return 2;//Gira a la derecha
              else
              return 3;//Gira a la izquerda
            }
         else if (Pos_Actual>=271&&Pos_Actual<=359)

              return 3;//Gira a la izquierda

          }//Fin del else if caso 3

    else if(Dir_Salida>=271 && Dir_Salida<=359){//Caso de coordenada de salida entre 271 y 359
         if (Pos_Actual>=0 && Pos_Actual<=90)
           return 3;
         else if(Pos_Actual>=91&&Pos_Actual<=180){
           Pos_Actual=Dir_Salida-Pos_Actual;

              if(Pos_Actual>180)
              return 3;//Gira a la izquierda

              else
              return 2;//Gira a la derecha
           }
         else if(Pos_Actual>=181&&Pos_Actual<=270)
            return 2;
         else if (Pos_Actual>=271&&Pos_Actual<=359){
            if(Pos_Actual<Dir_Salida)
            return 2;//Gira a la derecha
            else
            return 3;//Gira a la izquerda
          }

         }//fin del else if caso 4

  } //Fin del if del caso especial

     return 2; // Por default girar a la derecha
}

void Posicion(int datoX, int left, int front,int right,int PS,int T,int Vis)
{/*Cada arreglo  */

 USpos[datoX].ObsFre=front;
 USpos[datoX].ObsDer=right;
 USpos[datoX].ObsIzq=left;
 USpos[datoX].PasoAnt=PS; //Indica que paso anterior realizo para llegar ala casilla 1 Avanzo 2 GDer 3 GIzq
 USpos[datoX].Time=T;
 USpos[datoX].Visita=Vis;

}

void ObstaculosCasilla(int PS)//Funcion define inicialmente los obstaculos en cada casilla
{
  int accion;

  OF=0; OD=0; OI=0;
switch(USpos[x].Visita){
 case 0:
  //Al frente
    if(SensorValue[Eyes]>40 && omision!=1){
      OF=1;//Camino libre
      omision=0;
      }

  //A la derecha
       accion=HeadDer();
    if(SensorValue[Eyes]>30){
        OD=1;//Camino libre
       }
       wait1Msec(0300);
       HeadFront(accion);


  //A la izquierda
      accion=HeadIzq();
      wait1Msec(1000);
    if(SensorValue[Eyes]>30){
      OI=1;//Camino libre
      }
      wait1Msec(0300);
      HeadFront(accion);
     Posicion(x,OI,OF,OD,PS,tiempo_avance,1);
      break;

   case 1:
   Posicion(x+1,0,0,0,0,0,0);
   USpos[x].Visita=1+USpos[x].Visita;

   break;
   }

 /*Guarda informacion en la posicion actual
  x=la Posicion
  obstaculo izquierdo, frontal, derecho 0=obstaculo o no solucion 1=camino libre
  PS= Paso realizado previo a la entrada de la nueva Posicion
  tiempo de avance= tiempo que recorrio en Avanzar
  estacia= Numero de veces que se ha encontrado en esa posicion*/

}


int DecidirAccion()
{
  int a=1;     //variable de control en caso de problemas de giro
  int b=0;
  int cont=0;
  /*Regresa 1=frente
    Regresa 2=derecha
    Regresa 3=izquierda*/
  if(USpos[x].ObsFre==0&&USpos[x].ObsDer==0&&USpos[x].ObsIzq==0&&x!=0){

   switch(USpos[x].PasoAnt)
     {
       case 1:
            Reversa();
            USpos[x-1].ObsFre=0;
            return 4;
            break;
       case 2:
            Reversa();
            USpos[x-1].ObsDer=0;
            GiroDerecha(-1);
            return 4;
            break;
       case 3:
            Reversa();
            USpos[x-1].ObsIzq=0;
            GiroIzquierda(-1);
            return 4;
            break;
      }
    }

if (USpos[x].ObsFre==1){
    Avanzar();
    return 1;
    }

if(USpos[x].Visita==1){

   b=CasoCompass();
   if(USpos[x].ObsDer==1 && b==2){

      while(a!=0){
      a=GiroDerecha(1);
      if(cont==2){
        USpos[x].ObsDer=0; //existe un obstaculo
        return 0; // No pudo girar a la derecha
        }
      if(a==0)
      Avanzar();
      else
      ReversaCorreccion();
      cont++;
      }//fin del while
      return 2;//Giro hacia la derecha exitosamente
    }

  else if((USpos[x].ObsIzq==1&&USpos[x].ObsDer==0)||b==3){
    while(a!=0){
    a=GiroIzquierda(1);
    if(cont==2){
    USpos[x].ObsIzq=0;
    return 0;//no pudo girar a la izquierda
    }
    if(a==0)
    Avanzar();
    else
    ReversaCorreccion();
    cont++;
    }//Fin del while
    return 3;//Giro a la izquierda exitosamente
   }
}
else if(USpos[x].Visita==2){
 if(USpos[x].ObsDer==1){

      while(a!=0){
      a=GiroDerecha(1);
      if(cont==2){
        USpos[x].ObsDer=0; //existe un obstaculo
        return 0; // No pudo girar a la derecha
        }
      if(a==0)
      Avanzar();
      else
      ReversaCorreccion();
      cont++;
      }//fin del while
      return 2;//Giro hacia la derecha exitosamente
    }
   else if(USpos[x].ObsIzq==1&&USpos[x].ObsDer==0){
    while(a!=0){
    a=GiroIzquierda(1);
    if(cont==2){
    USpos[x].ObsIzq=0;
    return 0;//no pudo girar a la izquierda
    }
    if(a==0)
    Avanzar();
    else
    ReversaCorreccion();
    cont++;
    }//Fin del while
    return 3;//Giro a la izquierda exitosamente
   }
}
 return 0;
}





task main()
{

  while(true){
  nxtDisplayTextLine(0, "Robot Laberinto");
  nxtDisplayTextLine(1,"Por:");
  nxtDisplayTextLine(2,"Nicolas Morales S");
  nxtDisplayTextLine(3, "Press enter");
  nxtDisplayTextLine(4,"Indicar direccion");
  nxtDisplayCenteredTextLine(5,"de salida.");
  nxtDisplayTextLine(6,"DirSalida=%d",Dir_Salida);
  nxtDisplayTextLine(7,"Right for Start");

  while(nNxtButtonPressed == kEnterButton){
      Dir_Salida=SensorValue[Compass]*2;
    }
  if(nNxtButtonPressed==kRightButton){
    break;
   }
  }

   eraseDisplay();

    StartTask(MonitorSonar);
    StartTask(MonitorCompass);
    StartTask(MonitorLuz);
    StartTask(Pantalla);

  int PS;

  PS=0;

  while(x<20){

  ObstaculosCasilla(PS);


  PS=DecidirAccion();

  switch(PS)
  {
     case 4:// Caso en que se regresa el robot a una posicion anterior
     x--;
     break;

     default:
     x++;
     break;

  }//fin del switch


 }//fin del while
}//fin del main
